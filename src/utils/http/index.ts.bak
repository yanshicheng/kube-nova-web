/**
 * HTTP è¯·æ±‚å°è£…æ¨¡å—ï¼ˆä¿®å¤ç‰ˆï¼‰
 * åŸºäº Axios å°è£…çš„ HTTP è¯·æ±‚å·¥å…·ï¼Œæä¾›ç»Ÿä¸€çš„è¯·æ±‚/å“åº”å¤„ç†
 *
 * ## ä¿®å¤å†…å®¹
 * 1. ä¿®å¤é‡å¤æŠ¥é”™é—®é¢˜ï¼šåœ¨æ‹¦æˆªå™¨ä¸­ç»Ÿä¸€å¤„ç†é”™è¯¯ï¼Œä¸šåŠ¡å±‚ä¸å†é‡å¤æ˜¾ç¤º
 * 2. ä¿®å¤ message ç±»å‹é”™è¯¯ï¼šæ­£ç¡®å®šä¹‰ BaseResponse ç±»å‹
 * 3. ä¼˜åŒ–é”™è¯¯å¤„ç†æµç¨‹ï¼šåŒºåˆ†éœ€è¦è‡ªåŠ¨æ˜¾ç¤ºå’Œä¸éœ€è¦è‡ªåŠ¨æ˜¾ç¤ºçš„é”™è¯¯
 *
 * @module utils/http
 */

import axios, { AxiosRequestConfig, AxiosResponse, InternalAxiosRequestConfig } from 'axios'
import { ElMessageBox } from 'element-plus'
import { useUserStore } from '@/store/modules/user'
import { ApiStatus } from './status'
import { handleError, HttpError, showError, showSuccess } from './error'
import { BaseResponse } from '@/types'
import { router } from '@/router'

/** è¯·æ±‚é…ç½®å¸¸é‡ */
const REQUEST_TIMEOUT = 15000
const LOGOUT_DELAY = 500
const MAX_RETRIES = 0
const RETRY_DELAY = 1000
const UNAUTHORIZED_DEBOUNCE_TIME = 3000

/** ç‰¹æ®Šä¸šåŠ¡çŠ¶æ€ç  */
const BUSINESS_CODE = {
  SUCCESS: 0, // ä¸šåŠ¡æˆåŠŸ
  UNAUTHORIZED: 401, // æœªæˆæƒï¼ˆä¸šåŠ¡å±‚ï¼‰
  NEED_RESET_PASSWORD: 101112 // éœ€è¦é‡ç½®å¯†ç 
} as const

/** ä»¤ç‰Œç›¸å…³é”™è¯¯ç å®šä¹‰ */
const TOKEN_ERROR_CODES = {
  100091: 'ä»¤ç‰Œä¸èƒ½ä¸ºç©º',
  100092: 'æ— æ•ˆçš„ä»¤ç‰Œ',
  100093: 'ä»¤ç‰Œå·²è¿‡æœŸ',
  100094: 'ä»¤ç‰Œå·²è¢«ä½¿ç”¨ï¼Œè¯·é‡æ–°ç™»å½•',
  100095: 'æ— æ•ˆçš„ç­¾åç®—æ³•',
  100096: 'ä»¤ç‰Œæ ¼å¼é”™è¯¯',
  100097: 'ä»¤ç‰Œå°šæœªç”Ÿæ•ˆ',
  100098: 'ä»¤ç‰Œå£°æ˜æ— æ•ˆ',
  100002: 'ç™»å½•å¤±è´¥ï¼Œè¯·é‡æ–°ç™»å½•'
} as const

/** ä»¤ç‰Œé”™è¯¯é˜²æŠ–çŠ¶æ€ */
let isTokenErrorShown = false
let tokenErrorTimer: NodeJS.Timeout | null = null

/** 401 é˜²æŠ–çŠ¶æ€ */
let isUnauthorizedErrorShown = false
let unauthorizedTimer: NodeJS.Timeout | null = null

/** æ‰©å±• AxiosRequestConfig */
interface ExtendedAxiosRequestConfig extends AxiosRequestConfig {
  /** æ˜¯å¦æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ï¼ˆé»˜è®¤ trueï¼‰ */
  showErrorMessage?: boolean
  /** æ˜¯å¦æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯ï¼ˆé»˜è®¤ falseï¼‰ */
  showSuccessMessage?: boolean
}

/**
 * æ‰©å±•çš„ HttpErrorï¼Œæ·»åŠ æ ‡è®°å­—æ®µ
 * ç”¨äºæ ‡è¯†é”™è¯¯æ˜¯å¦å·²ç»è¢«æ˜¾ç¤ºè¿‡
 */
class ExtendedHttpError extends HttpError {
  /** æ ‡è®°é”™è¯¯æ˜¯å¦å·²æ˜¾ç¤º */
  isErrorShown: boolean = false
}

const { VITE_API_URL, VITE_WITH_CREDENTIALS } = import.meta.env

/** Axios å®ä¾‹ */
const axiosInstance = axios.create({
  timeout: REQUEST_TIMEOUT,
  baseURL: VITE_API_URL,
  withCredentials: VITE_WITH_CREDENTIALS === 'true',
  // HTTP çŠ¶æ€ç éªŒè¯ï¼šåªæœ‰ 2xx æ‰è®¤ä¸ºæ˜¯ä¼ è¾“å±‚æˆåŠŸ
  validateStatus: (status) => status >= 200 && status < 300,
  transformResponse: [
    (data, headers) => {
      const contentType = headers['content-type']
      if (contentType?.includes('application/json')) {
        try {
          return JSON.parse(data)
        } catch {
          return data
        }
      }
      return data
    }
  ]
})

/** è¯·æ±‚æ‹¦æˆªå™¨ */
axiosInstance.interceptors.request.use(
  (request: InternalAxiosRequestConfig) => {
    const { accessToken } = useUserStore()
    if (accessToken) request.headers.set('Authorization', `Bearer ${accessToken}`)

    if (request.data && !(request.data instanceof FormData) && !request.headers['Content-Type']) {
      request.headers.set('Content-Type', 'application/json')
      request.data = JSON.stringify(request.data)
    }

    return request
  },
  (error) => {
    showError(createHttpError('è¯·æ±‚é…ç½®é”™è¯¯', ApiStatus.error))
    return Promise.reject(error)
  }
)

/** å“åº”æ‹¦æˆªå™¨ */
axiosInstance.interceptors.response.use(
  (response: AxiosResponse<BaseResponse>) => {
    // æ­¤æ—¶ HTTP çŠ¶æ€ç å·²ç»æ˜¯ 200-299ï¼ˆç”± validateStatus ä¿è¯ï¼‰
    const { code, message } = response.data

    // å…¼å®¹ message å’Œ msg å­—æ®µ
    const errorMessage = message

    // ä¸šåŠ¡æˆåŠŸï¼ˆcode: 0ï¼‰
    if (code === BUSINESS_CODE.SUCCESS) {
      return response
    }

    // ä¸šåŠ¡å±‚æœªæˆæƒï¼ˆcode: 401ï¼‰
    if (code === BUSINESS_CODE.UNAUTHORIZED) {
      handleUnauthorizedError(errorMessage)
      // ä¸ä¼šæ‰§è¡Œåˆ°è¿™é‡Œï¼ŒhandleUnauthorizedError ä¼š throw error
    }

    // ä»¤ç‰Œç›¸å…³é”™è¯¯å¤„ç†ï¼ˆéœ€è¦å¼¹çª—ç¡®è®¤åè·³è½¬ç™»å½•ï¼‰
    if (isTokenErrorCode(code)) {
      void handleTokenError(code, errorMessage)
      // æŠ›å‡ºé”™è¯¯ä»¥ä¸­æ–­è¯·æ±‚é“¾ï¼Œå¹¶æ ‡è®°é”™è¯¯å·²æ˜¾ç¤º
      const error = createHttpError(errorMessage || getTokenErrorMessage(code), code)
      error.isErrorShown = true // æ ‡è®°é”™è¯¯å·²æ˜¾ç¤ºï¼ˆå¼¹çª—å¤„ç†ï¼‰
      throw error
    }

    // ç‰¹æ®Šä¸šåŠ¡ç ï¼šéœ€è¦é‡ç½®å¯†ç ï¼ˆ101112ï¼‰
    if (code === BUSINESS_CODE.NEED_RESET_PASSWORD) {
      void handleResetPasswordError(errorMessage)
      // æŠ›å‡ºé”™è¯¯ä»¥ä¸­æ–­è¯·æ±‚é“¾ï¼Œå¹¶æ ‡è®°é”™è¯¯å·²æ˜¾ç¤º
      const error = createHttpError(errorMessage || 'é¦–æ¬¡ç™»å½•éœ€è¦é‡ç½®å¯†ç ', code)
      error.isErrorShown = true // æ ‡è®°é”™è¯¯å·²æ˜¾ç¤ºï¼ˆå¼¹çª—å¤„ç†ï¼‰
      throw error
    }

    // ğŸ”§ ä¿®å¤ç‚¹ 1: å…¶ä»–ä¸šåŠ¡é”™è¯¯ç»Ÿä¸€åœ¨è¿™é‡Œå¤„ç†
    // åˆ›å»ºé”™è¯¯å¯¹è±¡
    const error = createHttpError(errorMessage || 'è¯·æ±‚å¤±è´¥', code)

    // æ ¹æ®è¯·æ±‚é…ç½®å†³å®šæ˜¯å¦æ˜¾ç¤ºé”™è¯¯
    const config = response.config as ExtendedAxiosRequestConfig
    const shouldShowError = config.showErrorMessage !== false // é»˜è®¤æ˜¾ç¤º

    if (shouldShowError) {
      showError(error, true)
      error.isErrorShown = true // æ ‡è®°é”™è¯¯å·²æ˜¾ç¤º
    }

    // æŠ›å‡ºé”™è¯¯ä¾›ä¸šåŠ¡å±‚æ•è·
    return Promise.reject(error)
  },
  (error) => {
    // HTTP å±‚é¢çš„é”™è¯¯ï¼ˆé 2xx çŠ¶æ€ç ï¼Œæˆ–ç½‘ç»œé”™è¯¯ï¼‰
    if (error.response) {
      // æœåŠ¡å™¨è¿”å›äº†é 2xx çš„çŠ¶æ€ç 
      const status = error.response.status

      // HTTP 401 æœªæˆæƒ
      if (status === 401) {
        handleUnauthorizedError('æœªæˆæƒï¼Œè¯·é‡æ–°ç™»å½•')
      }

      // å…¶ä»– HTTP é”™è¯¯
      const httpError = handleError(error)

      // æ˜¾ç¤º HTTP é”™è¯¯
      showError(httpError, true)
      ;(httpError as ExtendedHttpError).isErrorShown = true

      return Promise.reject(httpError)
    }

    // ç½‘ç»œé”™è¯¯æˆ–è¯·æ±‚è¶…æ—¶
    const networkError = handleError(error)

    // æ˜¾ç¤ºç½‘ç»œé”™è¯¯
    showError(networkError, true)
    ;(networkError as ExtendedHttpError).isErrorShown = true

    return Promise.reject(networkError)
  }
)

/** ç»Ÿä¸€åˆ›å»º ExtendedHttpError */
function createHttpError(message: string, code: number): ExtendedHttpError {
  const error = new HttpError(message, code) as ExtendedHttpError
  error.isErrorShown = false
  return error
}

/** æ£€æŸ¥æ˜¯å¦ä¸ºä»¤ç‰Œé”™è¯¯ç  */
function isTokenErrorCode(code: number): code is keyof typeof TOKEN_ERROR_CODES {
  return code in TOKEN_ERROR_CODES
}

/** è·å–ä»¤ç‰Œé”™è¯¯æ¶ˆæ¯ */
function getTokenErrorMessage(code: number): string {
  return TOKEN_ERROR_CODES[code as keyof typeof TOKEN_ERROR_CODES] || 'ç™»å½•å·²å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•'
}

/** å¤„ç†éœ€è¦é‡ç½®å¯†ç çš„é”™è¯¯ï¼ˆä¸šåŠ¡ç  101112ï¼‰ */
async function handleResetPasswordError(message?: string): Promise<void> {
  const errorMessage = message || 'é¦–æ¬¡ç™»å½•éœ€è¦é‡ç½®å¯†ç '

  try {
    await ElMessageBox.confirm(errorMessage + 'ï¼Œæ˜¯å¦å‰å¾€é‡ç½®å¯†ç é¡µé¢ï¼Ÿ', 'éœ€è¦é‡ç½®å¯†ç ', {
      confirmButtonText: 'å‰å¾€é‡ç½®',
      cancelButtonText: 'å–æ¶ˆ',
      type: 'warning',
      center: true
    })

    // ç”¨æˆ·ç‚¹å‡»ç¡®è®¤ï¼Œè·³è½¬åˆ°é‡ç½®å¯†ç é¡µé¢
    const username = useUserStore().info?.userName || ''
    await router.push({
      name: 'ResetPassword',
      query: username ? { username } : undefined
    })
  } catch {
    // ç”¨æˆ·ç‚¹å‡»å–æ¶ˆï¼Œè·³è½¬åˆ°ç™»å½•é¡µ
    await router.push({ name: 'Login' })
  }
}

/** å¤„ç†ä»¤ç‰Œé”™è¯¯ï¼ˆå¸¦é˜²æŠ–å’Œç¡®è®¤å¯¹è¯æ¡†ï¼‰ */
async function handleTokenError(code: number, message?: string): Promise<void> {
  const errorMessage = message || getTokenErrorMessage(code)

  // é˜²æŠ–å¤„ç†ï¼šé¿å…å¤šä¸ªè¯·æ±‚åŒæ—¶è§¦å‘å¤šä¸ªå¼¹çª—
  if (!isTokenErrorShown) {
    isTokenErrorShown = true

    try {
      await ElMessageBox.confirm(errorMessage, 'ç™»å½•å·²å¤±æ•ˆ', {
        confirmButtonText: 'ç¡®å®š',
        showCancelButton: false,
        closeOnClickModal: false,
        closeOnPressEscape: false,
        type: 'warning',
        center: true
      })
    } catch {
      // ç”¨æˆ·å…³é—­å¯¹è¯æ¡†ï¼Œå¿½ç•¥é”™è¯¯
    } finally {
      logOut()

      // å»¶è¿Ÿé‡ç½®é˜²æŠ–çŠ¶æ€
      tokenErrorTimer = setTimeout(() => {
        isTokenErrorShown = false
        if (tokenErrorTimer) {
          clearTimeout(tokenErrorTimer)
          tokenErrorTimer = null
        }
      }, UNAUTHORIZED_DEBOUNCE_TIME)
    }
  }
}

/** å¤„ç† 401 é”™è¯¯ï¼ˆå¸¦é˜²æŠ–ï¼‰ */
function handleUnauthorizedError(message?: string): never {
  const error = createHttpError(message || 'æœªæˆæƒï¼Œè¯·é‡æ–°ç™»å½•', BUSINESS_CODE.UNAUTHORIZED)

  if (!isUnauthorizedErrorShown) {
    isUnauthorizedErrorShown = true
    logOut()

    unauthorizedTimer = setTimeout(resetUnauthorizedError, UNAUTHORIZED_DEBOUNCE_TIME)

    showError(error, true)
    error.isErrorShown = true
  }

  throw error
}

/** é‡ç½® 401 é˜²æŠ–çŠ¶æ€ */
function resetUnauthorizedError(): void {
  isUnauthorizedErrorShown = false
  if (unauthorizedTimer) clearTimeout(unauthorizedTimer)
  unauthorizedTimer = null
}

/** é€€å‡ºç™»å½•å‡½æ•° */
function logOut(): void {
  setTimeout(() => {
    useUserStore().logOut()
  }, LOGOUT_DELAY)
}

/** æ˜¯å¦éœ€è¦é‡è¯•ï¼ˆä»…é’ˆå¯¹ HTTP å±‚é¢çš„é”™è¯¯ï¼‰ */
function shouldRetry(statusCode: number): boolean {
  const retryableCodes = [408, 500, 502, 503, 504]
  return retryableCodes.includes(statusCode)
}

/** è¯·æ±‚é‡è¯•é€»è¾‘ */
async function retryRequest<T>(
  config: ExtendedAxiosRequestConfig,
  retries = MAX_RETRIES
): Promise<T> {
  try {
    return await request<T>(config)
  } catch (error) {
    if (retries > 0 && error instanceof HttpError && shouldRetry(error.code)) {
      await delay(RETRY_DELAY)
      return retryRequest<T>(config, retries - 1)
    }
    throw error
  }
}

/** å»¶è¿Ÿå‡½æ•° */
function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms))
}

/** è¯·æ±‚å‡½æ•° */
async function request<T = any>(config: ExtendedAxiosRequestConfig): Promise<T> {
  // POST | PUT å‚æ•°è‡ªåŠ¨å¡«å……
  if (
    ['POST', 'PUT'].includes(config.method?.toUpperCase() || '') &&
    config.params &&
    !config.data
  ) {
    config.data = config.params
    config.params = undefined
  }

  try {
    const res = await axiosInstance.request<BaseResponse<T>>(config)

    // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
    if (config.showSuccessMessage && res.data.message) {
      showSuccess(res.data.message || 'æ“ä½œæˆåŠŸ')
    }

    return res.data.data as T
  } catch (error) {
    // ğŸ”§ ä¿®å¤ç‚¹ 2: ç»Ÿä¸€é”™è¯¯å¤„ç†ï¼Œä¸å†é‡å¤æ˜¾ç¤º
    // æ‰€æœ‰é”™è¯¯éƒ½å·²ç»åœ¨æ‹¦æˆªå™¨ä¸­å¤„ç†è¿‡äº†ï¼Œè¿™é‡Œåªéœ€è¦ä¼ é€’é”™è¯¯

    // å¦‚æœé”™è¯¯å·²ç»è¢«æ˜¾ç¤ºè¿‡ï¼Œç›´æ¥æŠ›å‡º
    if (error instanceof ExtendedHttpError && error.isErrorShown) {
      throw error
    }

    // å¦‚æœæ˜¯å…¶ä»–æœªå¤„ç†çš„é”™è¯¯ï¼Œä¹Ÿç›´æ¥æŠ›å‡º
    throw error
  }
}

/** API æ–¹æ³•é›†åˆ */
const api = {
  /**
   * GET è¯·æ±‚
   * @param config è¯·æ±‚é…ç½®
   * @param config.showErrorMessage æ˜¯å¦æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ï¼ˆé»˜è®¤ trueï¼‰
   */
  get<T>(config: ExtendedAxiosRequestConfig) {
    return retryRequest<T>({ ...config, method: 'GET' })
  },

  /**
   * POST è¯·æ±‚
   * @param config è¯·æ±‚é…ç½®
   * @param config.showErrorMessage æ˜¯å¦æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ï¼ˆé»˜è®¤ trueï¼‰
   * @param config.showSuccessMessage æ˜¯å¦æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯ï¼ˆé»˜è®¤ falseï¼‰
   */
  post<T>(config: ExtendedAxiosRequestConfig) {
    return retryRequest<T>({ ...config, method: 'POST' })
  },

  /**
   * PUT è¯·æ±‚
   * @param config è¯·æ±‚é…ç½®
   * @param config.showErrorMessage æ˜¯å¦æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ï¼ˆé»˜è®¤ trueï¼‰
   * @param config.showSuccessMessage æ˜¯å¦æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯ï¼ˆé»˜è®¤ falseï¼‰
   */
  put<T>(config: ExtendedAxiosRequestConfig) {
    return retryRequest<T>({ ...config, method: 'PUT' })
  },

  /**
   * DELETE è¯·æ±‚
   * @param config è¯·æ±‚é…ç½®
   * @param config.showErrorMessage æ˜¯å¦æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ï¼ˆé»˜è®¤ trueï¼‰
   * @param config.showSuccessMessage æ˜¯å¦æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯ï¼ˆé»˜è®¤ falseï¼‰
   */
  del<T>(config: ExtendedAxiosRequestConfig) {
    return retryRequest<T>({ ...config, method: 'DELETE' })
  },

  /**
   * è‡ªå®šä¹‰è¯·æ±‚
   * @param config è¯·æ±‚é…ç½®
   */
  request<T>(config: ExtendedAxiosRequestConfig) {
    return retryRequest<T>(config)
  }
}

export default api
